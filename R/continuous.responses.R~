#' Description: Quantify association between modes and continuous variable
#' 
#' Arguments:
#'   @param annotation.vector annotation vector with discrete factor levels, and named by the samples
#'   @param model NetResponse model object
#'   @param method method for enrichment calculation
#'   @param min.size minimum sample size for a response 
#'   @param data data matrix (samples x features)
#'
#' Returns:
#'   @return List with each element corresponding to one variable and listing the responses according to association strength
#'            
#' @author Contact: Leo Lahti \email{leo.lahti@@iki.fi}
#' @references See citation("netresponse")
#' @export
#' @keywords utilities
continuous.responses <- function (annotation.vector, model, method = "t-test", min.size = 2, data = NULL) {
		    
  # method = "t-test"; min.size = 2; data = t(dat[, gpt])		     

  if (is.null(data) && class(model) == "NetResponseModel") {
    data <- model@datamatrix
  } else if (is.null(data)) {
    stop("Provide data")
  }

  # samples x features
  if(is.vector(data)) {
    data2 <- matrix(data)
    rownames(data2) <- names(data)
    data <- data2
  }

  all.samples <- rownames(data)
  annotated.samples <- names(which(!is.na(annotation.vector)))
  annotation.data <- annotation.vector[annotated.samples]
  names(annotation.data) <- annotated.samples

  associations <- NULL  	 
  if (class(model) == "NetResponseModel") {

    subnets <- get.subnets(model, min.size = min.size)

    for (sn in names(subnets)) {

      # samples in each mode (hard assignment)
      r2s <- response2sample(model, subnet.id = sn)

      pvals <- c()
      mean.difference <- c()
      for (mo in 1:length(r2s)) {

        # annotated samples in the mode
        s <- intersect(r2s[[mo]], annotated.samples)

	# annotated samples in other modes
        sc <- intersect(unlist(r2s[-mo]), annotated.samples)

        if (length(na.omit(s)) > 1 && length(na.omit(sc)) > 1) {      
          pvals[[mo]] <- t.test(annotation.data[s], annotation.data[sc])$p.value
          mean.difference[[mo]] <- mean(annotation.data[s]) - mean(annotation.data[sc])

        } else {
          warning(paste("Not enough annotated observations for response", mo))
          pvals[[mo]] <- NA
	  mean.difference[[mo]] <- NA
        }
      }

      associations <- rbind(associations, cbind(subnet = rep(sn, length(r2s)), mode = 1:length(r2s), pvalue = pvals, mean.difference = mean.difference))

    }

    associations <- data.frame(list(subnet = associations[, "subnet"], 
    		    	            mode = associations[, "mode"], 
    		    	            pvalue = as.numeric(associations[, "pvalue"]), 
    		    	            mean.difference = as.numeric(associations[, "mean.difference"])
    				    ))

  } else if (class(model) == "list") {

    # for mixture.model output, for instance; assuming there is only a single 'subnet'
         
    # samples in each mode (hard assignment)
    r2s <- model$qofz
    if (is.null(rownames(r2s))) {rownames(r2s) <- colnames(data)}
    clusters <- apply(r2s, 1, which.max)
    names(clusters) <- rownames(data)
    r2s <- split(names(clusters), clusters)

    #r2s <- response2sample(model, data = t(data))

    pvals <- c()
    mean.difference <- c()
    for (mo in 1:length(r2s)) {

      # annotated samples in the mode
      s <- intersect(r2s[[mo]], annotated.samples)

      # annotated samples in other modes
      sc <- intersect(unlist(r2s[-mo]), annotated.samples)

      if (length(na.omit(s)) > 1 && length(na.omit(sc)) > 1) {      
        pvals[[mo]] <- t.test(annotation.data[s], annotation.data[sc])$p.value
	mean.difference[[mo]] <- mean(annotation.data[s]) - mean(annotation.data[sc])
      } else {
        warning(paste("Not enough annotated observations for response", mo))
        pvals[[mo]] <- NA
        mean.difference[[mo]] <- NA
      }
    }

    associations <- data.frame(list(mode = 1:length(r2s), pvalue = pvals, mean.difference = mean.difference))

  }

  associations

}
